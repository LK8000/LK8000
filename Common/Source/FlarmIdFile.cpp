/*
 * LK8000 Tactical Flight Computer -  WWW.LK8000.IT
 * Released under GNU/GPL License v.2 or later
 * See CREDITS.TXT file for authors and copyrights
 */

#include "externs.h"
#include "FlarmIdFile.h"
#include "utils/array_back_insert_iterator.h"
#include "utils/zzip_stream.h"
#include "utils/charset_helper.h"
#include <iostream>
#include "LocalPath.h"

namespace {

std::string::const_iterator GetAsString(std::string::const_iterator it, size_t size, TCHAR *res) {

  auto out = array_back_inserter(res, size - 1); // size - 1 to let placeholder for '\0'
  for(unsigned i = 0; i < (size -1); ++i) {
    out = (HexDigit(*(it++)) << 4) | HexDigit(*(it++));
  }
  *out = _T('\0');

  // remove trailing whitespace
  TCHAR* end = res + size - 1;
  while ((--end) >= res && _istspace(*end)) {
    *end = _T('\0');
  }
  return it;
}

void ExtractOgnField(const tstring& Source, TCHAR* Destination, int DesiredFieldNumber) {
  int dest_index = 0;
  int CurrentFieldNumber = 0;

  auto sptr = Source.begin();
  auto eptr = Source.end();

  if (!Destination) {
    return;
  }

  while ((CurrentFieldNumber < DesiredFieldNumber) && (sptr < eptr)) {
    if (*sptr == ',') {
      CurrentFieldNumber++;
    }
    ++sptr;
  }

  Destination[0] = '\0';  // set to blank in case it's not found..

  if (CurrentFieldNumber == DesiredFieldNumber) {
    while ((sptr < eptr) && (*sptr != ',') && (*sptr != '\0')) {
      Destination[dest_index] = *sptr;
      ++sptr;
      if (Destination[dest_index] != '\'')  // remove '
        ++dest_index;
    }
    Destination[dest_index] = '\0';
  }
}

} // namespace

FlarmId::FlarmId(const std::string& string) {
  if(string.length() != 172) {
    throw std::runtime_error("invalid flarmnet record");
  }

  auto it = string.begin();
  it = GetAsString(it, FLARMID_SIZE_ID, id);
  it = GetAsString(it, FLARMID_SIZE_NAME, name);
  it = GetAsString(it, FLARMID_SIZE_AIRFIELD, airfield);
  it = GetAsString(it, FLARMID_SIZE_TYPE, type);
  it = GetAsString(it, FLARMID_SIZE_REG, reg);
  it = GetAsString(it, FLARMID_SIZE_CN, cn);
  it = GetAsString(it, FLARMID_SIZE_FREQ, freq);


  // Add a valid CN if missing. Ex: D-6543 = D43
  if (_tcslen(cn) == 0 ) {
    int reglen=_tcslen(reg);
    if (reglen >=3) {
      cn[0] = reg[0];
      cn[1] = reg[reglen-2];
      cn[2] = reg[reglen-1];
      cn[3] = _T('\0');
    }
  }
}


void FlarmIdFile::LoadOgnDb() {

  TCHAR OGNIdFileName[MAX_PATH] = _T("");
  LocalPath(OGNIdFileName, _T(LKD_CONF), _T("data.ogn"));

  /*
   * we can't use std::ifstream due to lack of unicode file name in mingw32
   */
  zzip_stream file(OGNIdFileName, "rt");
  if (!file) {
    return;
  }


  std::string src_line;
  src_line.reserve(512);
  unsigned int Doublicates = 0;
  unsigned int InvalidIDs = 0;
  std::istream stream(&file);
  while (std::getline(stream, src_line)) {
    try {

      if (src_line.empty() || src_line.front() == '#') {
        continue; // skip empty line and comments
      }

      tstring t_line = from_unknown_charset(src_line.c_str());

      TCHAR id[7] = {};
      ExtractOgnField(t_line, id, 1);
      uint32_t RadioId = _tcstoul(id, nullptr, 16);

      auto ib = flarmIds.emplace(RadioId, nullptr);
      if (ib.second) {
        // new item instead ?
        auto flarmId = std::make_unique<FlarmId>();

        lk::strcpy(flarmId->id, id);
        ExtractOgnField(t_line, flarmId->reg, 3);
        if (_tcslen(flarmId->reg) == 0) {
          // reg empty use id...
          _stprintf(flarmId->reg, _T("%X"), RadioId);
          InvalidIDs++;
        }

        ExtractOgnField(t_line, flarmId->type, 2);
        _stprintf(flarmId->name, _T("OGN: %X"), RadioId);
        ExtractOgnField(t_line, flarmId->cn, 4);

        ib.first->second = std::move(flarmId);  // transfert flarmId ownership to 'flarmIds' map.
      } else {
        Doublicates++;
      }

    } catch (std::exception& e) {
      StartupStore(_T("%s"), to_tstring(e.what()).c_str());
    }
  }
  if (InvalidIDs > 0)
    StartupStore(_T(". found %u invalid IDs in OGN database"),InvalidIDs);	
  if (Doublicates > 0)
    StartupStore(_T(". found %u IDs also in OGN database -> ignored"),Doublicates);
}


void FlarmIdFile::LoadFlarmnetDb() {

  TCHAR flarmIdFileName[MAX_PATH] = _T("");
  LocalPath(flarmIdFileName, _T(LKD_CONF), _T(LKF_FLARMNET));

  /*
   * we can't use std::ifstream due to lack of unicode file name in mingw32
   */
  zzip_stream file(flarmIdFileName, "rt");
  if (!file) {
    LocalPath(flarmIdFileName, _T(LKD_CONF), _T("data.fln"));
    file.open(flarmIdFileName, "rt");
  }
  if (file) {
    std::string src_line;
    src_line.reserve(173);

    std::istream stream(&file);
    std::getline(stream, src_line); // skip first line
    while (std::getline(stream, src_line)) {
      if (src_line.length() != 172) {
        continue; // avoid crash due to broken exception handling on WinCE target
      }

      try {
        auto flarmId = std::make_unique<FlarmId>(src_line);
        flarmIds.emplace(flarmId->GetId(), std::move(flarmId));
      } catch (std::exception& e) {
        StartupStore(_T("%s"), to_tstring(e.what()).c_str());
      }
    }
  }
}

FlarmIdFile::FlarmIdFile() {

  LoadFlarmnetDb();
  auto FlamnetCnt = static_cast<unsigned>(flarmIds.size());
  StartupStore(_T(". FLARMNET database, found %u IDs"), FlamnetCnt);

  LoadOgnDb();
  auto OgnCnt = static_cast<unsigned>(flarmIds.size() - FlamnetCnt);
  StartupStore(_T(". OGN database, found additinal %u IDs"), OgnCnt);

  StartupStore(_T(". total %u Flarm device IDs found!"), static_cast<unsigned>(flarmIds.size()));
}

FlarmIdFile::~FlarmIdFile() {
  flarmIds.clear();
}

const FlarmId* FlarmIdFile::GetFlarmIdItem(uint32_t id) const {
  auto it = flarmIds.find(id);
  if (it != flarmIds.end()) {
    return it->second.get();
  }
  return nullptr;
}

const FlarmId* FlarmIdFile::GetFlarmIdItem(const TCHAR *cn) const {
  auto it = std::find_if(std::begin(flarmIds), std::end(flarmIds), [&](auto& item) {
    return (item.second && _tcscmp(item.second->cn, cn) == 0);
  });

  if (it != flarmIds.end()) {
    return it->second.get();
  }
  return nullptr;
}

uint32_t FlarmId::GetId() const {
  return _tcstoul(id, nullptr, 16);
}
